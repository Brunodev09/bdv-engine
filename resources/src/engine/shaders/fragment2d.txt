#version 400 core

in vec2 passTextureCoordinates;
in vec4 vertexPosition;

layout(location = 0) out vec4 out_Color;

uniform sampler2D textureSampler;
uniform vec3 colorOffset;
uniform vec3 ambientLight;
uniform float tick;

uniform bool toggleGlow = false;
uniform vec3 glowColor;

vec4 applyAmbientLighting(vec4 uv, vec4 pixelColor) {
    vec4 outputFragment;
    vec2 lightPos = vec2(0.4, 0.3);
    vec3 lightCol = vec3(1, 1, 1);
    float lightIntensity = 0.8;

    float distance = distance(lightPos, uv.xy);
    float diffuse = 0.0;

    if (distance <= lightIntensity) diffuse =  1.0 - abs(distance / lightIntensity);
    if (diffuse <= 0.3) diffuse = 0.3;

    outputFragment = vec4(colorOffset, 1.0) * vec4(min(pixelColor.rgb * ((lightCol * diffuse) + ambientLight),
                pixelColor.rgb), 1.0);

    return outputFragment;
}

float applyGlow(vec4 uv, vec2 p, float r, float blur) {
//    uv -= vec4(1, 0.5, 0, 0);
    float d = length(uv.xy - p);
    return smoothstep(r, r-blur, d);
}


void main(void) {
    bool ambientToggle;

    if (ambientLight.x >= 0.5 || ambientLight.x <= 0.5) {
        ambientToggle = true;
    } else ambientToggle = false;

    vec4 pixelColor = texture(textureSampler, passTextureCoordinates);
    vec4 outputColor;

    if (pixelColor.a < 1.0) discard;

    outputColor = vec4(colorOffset, 1.0) * pixelColor;

    if (ambientToggle) {
        outputColor = applyAmbientLighting(vertexPosition, pixelColor);
    }

    if (toggleGlow) {
        float mask = applyGlow(vertexPosition, vec2(0.5), 0.3, 0.2);
        outputColor = vec4(glowColor, 1.0) * mask;
        outputColor += pixelColor;
        if (ambientToggle) {
            outputColor -= applyAmbientLighting(vertexPosition, pixelColor);
        }
    }

    out_Color = outputColor;
}

